
Java虚拟机无法直接执行字节码, 需要先编译成机器码, 有两种方式:
1. 解释执行: 逐条将字节码翻译成机器码并执行, 可以无需等待编译
2. 即时编译JIT: 一次将一个方法的所有代码全部翻译成机器码、然后再执行. 实际运行速度更快

HotSpot是混合模式, 先解释执行字节码、然后将反复执行的热点代码已方法为单位进行即时编译

与静态编译相比、即时编译拥有程序的运行时信息、且可以根据这个信息作出优化、所以效率是最可能超过 静态编译C++的

HotSpot内置了 C1, C2, Graal(Java10引入、实验性) 等即时编译器, 以便在多个编译效率和编译后代码的执行时间上做取舍

`C1`: 又称Client模式、是针对对启动性能有要求的客户端GUI程序, 采用的优化手段相对简单, 
编译时间较短. 

`C2`: Server模式, 针对对峰值性能有要求的服务端程序、编译手段复杂、时间较长, 但生成的代码执行效率高
从Java7开始、采用的是分层编译, 热点代码会先被C1编译、然后热点中的热点会进一步被C2编译.

为了不干扰正常的应用程序、HotSpot的即时编译是放在另外的编译线程执行的
会根据CPU的数量设置编译线程的数目, 并且按照1:2 的比例配置给 C1 和 C2 编译器
在计算机资源充足的情况下、字节码的解释执行和编译执行会同时进行, 编译完成后的机器码会在下次调用该方法时启用、以替代原本的解释执行


`语义解析`会做下边的事情:
1. 为无构造方法的类型添加缺省的构造方法
2. 检查变量是否在使用前都已初始化
3. 检查类型变量是否与值匹配
4. 将String类型中的常量合并
5. 是否所有的操作语句都可达
6. 异常检查
7. 解除Java语法糖

Java语言的类型可以分为: 基本类型和引用类型(类、接口、数组类、泛型类)

1. `加载`: 是指查找字节流、并创建类的过程. 
对于数组类, 无对应的字节流, 是Java虚拟机直接生成的. 对于其它类、Java虚拟机则需要借助类加载器完成查找字节流的过程

`双亲委派`: 类加载器会将加载请求转交父类处理、父类加载不到、才交给子类自己处理

2. `链接`: 是指将创建成的类合并至Java虚拟机中、使其能够执行的过程. 分为: `验证`、`准备`、`解析` 三个阶段.
`验证阶段`: 确保加载的类是满足Java虚拟机的约束条件的.
`准备阶段`: 为被加载的类的静态字段分配内存
`解析阶段`: 将符号引用解析成实际引用. 若符号引用指向未被加载的类或者未被加载类的字段或方法, 解析阶段会触发未加载类的加载.

3. `初始化`: 
静态字段可以在声明时赋值、也可以在静态代码块中赋值. 若直接赋值的静态字段是 final 的、且是`基本类型`或者`字符串`, 就会被编译器标记为 `常量值`, 
由jvm直接完成. 除此之外的直接赋值操作及所有静态代码块中的代码、则会被置于同一方法 <cinit> 中
初始化的过程会完成 常量值的赋值 和 cinit 的方法执行. jvm会通过加锁保证 cinit 只执行一次.

类加载时机:
1. jvm启动时、加载用户指定的主类.
2. 遇到new指令时、初始化 new 指令的目标类
3. 遇到调用静态方法的指令时、初始化该静态方法所在的类
4. 遇到访问静态字段的指令时、初始化静态字段所在的类
5. 子类的初始化会触发父类的初始化
6. 若一个接口定义了default方法, 则直接实现或间接实现该接口的类的初始化会触发该接口的初始化
7. 使用反射api对某个类进行反射调用时、初始化这个类
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类




 
